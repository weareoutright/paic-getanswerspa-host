{"version":3,"file":"field-transformers.js","names":["getFieldTransformers","pluginOptions","getPluginOptions","prefix","schema","typePrefix","description","test","field","type","kind","ofType","transform","typeIsABuiltInScalar","findNamedTypeName","name","typeName","normalizedTypeName","buildTypeName","implementsNodeInterface","getStore","getState","remoteSchema","typeMap","get","interfaces","some","i","isAListOfGatsbyNodeInterfaces","args","transformListOfGatsbyNodes","fieldName","originalTypeName","typeKind","findTypeKind","resolve","source","resolvedField","autoAliasedFieldPropertyName","aliasedField","gatsbyNodeTypes","getGatsbyNodeTypeNames","isAnInterfaceTypeOfGatsbyNodes","possibleTypes","filter","possibleType","typeIsExcluded","every","includes","transformGatsbyNodeObject","find","transformListOfUnions","transformUnion"],"sources":["../../../../src/steps/create-schema-customization/transform-fields/field-transformers.js"],"sourcesContent":["import { buildTypeName, findNamedTypeName, findTypeKind } from \"../helpers\"\nimport { transformUnion, transformListOfUnions } from \"./transform-union\"\nimport {\n  transformListOfGatsbyNodes,\n  transformGatsbyNodeObject,\n} from \"./transform-object\"\nimport { getGatsbyNodeTypeNames } from \"../../source-nodes/fetch-nodes/fetch-nodes\"\nimport { typeIsABuiltInScalar } from \"~/steps/create-schema-customization/helpers\"\nimport { getStore } from \"~/store\"\nimport { typeIsExcluded } from \"~/steps/ingest-remote-schema/is-excluded\"\nimport { getPluginOptions } from \"~/utils/get-gatsby-api\"\n\nexport const getFieldTransformers = () => {\n  const pluginOptions = getPluginOptions()\n  const prefix = pluginOptions.schema.typePrefix\n  return [\n    {\n      description: `NON_NULL Scalar`,\n      test: field =>\n        field.type.kind === `NON_NULL` && field.type.ofType.kind === `SCALAR`,\n\n      transform: ({ field }) => {\n        if (typeIsABuiltInScalar(field.type)) {\n          return `${findNamedTypeName(field.type.ofType)}!`\n        } else {\n          return `JSON!`\n        }\n      },\n    },\n\n    {\n      description: `NON_NULL list type`,\n      test: field =>\n        field.type.kind === `NON_NULL` &&\n        field.type.ofType.kind === `LIST` &&\n        (field.type.ofType.name || field.type.ofType?.ofType?.name),\n\n      transform: ({ field }) => {\n        const typeName = findNamedTypeName(field.type)\n        const normalizedTypeName = typeIsABuiltInScalar(field.type)\n          ? typeName\n          : buildTypeName(typeName, prefix)\n\n        return `[${normalizedTypeName}]!`\n      },\n    },\n\n    {\n      description: `Lists of Gatsby node interfaces`,\n      test: field => {\n        const implementsNodeInterface = getStore()\n          .getState()\n          .remoteSchema.typeMap.get(findNamedTypeName(field.type))\n          ?.interfaces?.some(i => i.name === `Node`)\n\n        const isAListOfGatsbyNodeInterfaces =\n          (field.type.kind === `LIST` || field.type.ofType?.kind === `LIST`) &&\n          implementsNodeInterface\n\n        return isAListOfGatsbyNodeInterfaces\n      },\n\n      transform: args => transformListOfGatsbyNodes({ ...args, pluginOptions }),\n    },\n\n    {\n      description: `NON_NULL lists of NON_NULL types`,\n      test: field =>\n        field.type.kind === `NON_NULL` &&\n        field.type.ofType.kind === `LIST` &&\n        field.type.ofType?.ofType?.kind === `NON_NULL`,\n\n      transform: ({ field, fieldName }) => {\n        const originalTypeName = findNamedTypeName(field.type)\n        const typeKind = findTypeKind(field.type)\n\n        const normalizedTypeName =\n          typeKind === `SCALAR` && typeIsABuiltInScalar(field.type)\n            ? originalTypeName\n            : buildTypeName(originalTypeName, prefix)\n\n        return {\n          type: `[${normalizedTypeName}!]!`,\n          resolve: source => {\n            const resolvedField = source[fieldName]\n\n            if (typeof resolvedField !== `undefined`) {\n              return resolvedField ?? []\n            }\n\n            const autoAliasedFieldPropertyName = `${fieldName}__typename_${field?.type?.name}`\n\n            const aliasedField = source[autoAliasedFieldPropertyName]\n\n            return aliasedField ?? []\n          },\n        }\n      },\n    },\n\n    {\n      description: `Lists of NON_NULL builtin types`,\n      test: field =>\n        field.type.kind === `LIST` &&\n        field.type.ofType.kind === `NON_NULL` &&\n        (field.type.ofType.name ?? field.type.ofType?.ofType?.name) &&\n        typeIsABuiltInScalar(field.type),\n\n      transform: ({ field }) => `[${findNamedTypeName(field.type)}!]`,\n    },\n\n    {\n      description: `Lists of NON_NULL types`,\n      test: field =>\n        field.type.kind === `LIST` &&\n        field.type.ofType.kind === `NON_NULL` &&\n        (field.type.ofType.name ?? field.type.ofType?.ofType?.name),\n\n      transform: ({ field }) =>\n        `[${buildTypeName(findNamedTypeName(field.type), prefix)}!]`,\n    },\n\n    {\n      description: `ENUM type`,\n      test: field => field.type.kind === `ENUM`,\n      transform: ({ field }) => buildTypeName(field.type.name, prefix),\n    },\n\n    {\n      description: `Scalar type`,\n      test: field => field.type.kind === `SCALAR`,\n      transform: ({ field }) => {\n        if (typeIsABuiltInScalar(field.type)) {\n          return field.type.name\n        } else {\n          // custom scalars are typed as JSON\n          // @todo if frequently requested,\n          // make this hookable so a plugin could register a custom scalar\n          return `JSON`\n        }\n      },\n    },\n\n    {\n      description: `Gatsby Node Objects or Gatsby Node Interfaces where all possible types are Gatsby Nodes`,\n      test: field => {\n        const gatsbyNodeTypes = getGatsbyNodeTypeNames()\n\n        const pluginOptions = getPluginOptions()\n\n        const isAnInterfaceTypeOfGatsbyNodes =\n          // if this is an interface\n          field.type.kind === `INTERFACE` &&\n          // and every possible type is a future gatsby node\n          getStore()\n            .getState()\n            // get the full type for this interface\n            .remoteSchema.typeMap.get(findNamedTypeName(field.type))\n            // filter out any excluded types\n            .possibleTypes?.filter(\n              possibleType =>\n                !typeIsExcluded({\n                  pluginOptions,\n                  typeName: possibleType.name,\n                })\n            )\n            // if every remaining type is a Gatsby node type\n            // then use this field transformer\n            ?.every(possibleType => gatsbyNodeTypes.includes(possibleType.name))\n\n        return (\n          (gatsbyNodeTypes.includes(field.type.name) &&\n            field.type.kind === `OBJECT`) ||\n          isAnInterfaceTypeOfGatsbyNodes\n        )\n      },\n\n      transform: args => transformGatsbyNodeObject({ ...args, pluginOptions }),\n    },\n\n    {\n      description: `Lists of Gatsby Node Object types`,\n      test: field => {\n        const gatsbyNodeTypes = getGatsbyNodeTypeNames()\n\n        const {\n          remoteSchema: { typeMap },\n        } = getStore().getState()\n\n        return (\n          // this is a list of Gatsby nodes\n          (field.type.kind === `LIST` &&\n            field.type.ofType.kind === `OBJECT` &&\n            gatsbyNodeTypes.includes(field.type.ofType.name)) ||\n          // or it's a list of an interface type which Gatsby nodes implement\n          (field.type.kind === `LIST` &&\n            field.type.ofType.kind === `INTERFACE` &&\n            typeMap\n              .get(field.type.ofType.name)\n              ?.possibleTypes?.find(possibleType =>\n                gatsbyNodeTypes.includes(possibleType.name)\n              ))\n        )\n      },\n\n      transform: args => transformListOfGatsbyNodes({ ...args, pluginOptions }),\n    },\n\n    {\n      description: `Non-Gatsby Node Objects`,\n      test: field => field.type.kind === `OBJECT`,\n      transform: ({ field }) => buildTypeName(field.type.name, prefix),\n    },\n\n    {\n      description: `Lists of Non Gatsby Node Objects`,\n      test: field =>\n        field.type.kind === `LIST` &&\n        (field.type.ofType.kind === `OBJECT` ||\n          field.type.ofType.kind === `ENUM`),\n\n      transform: ({ field }) =>\n        `[${buildTypeName(field.type.ofType.name, prefix)}]`,\n    },\n\n    {\n      description: `Lists of Union types`,\n      test: field =>\n        field.type.kind === `LIST` && field.type.ofType.kind === `UNION`,\n\n      transform: args => transformListOfUnions({ ...args, pluginOptions }),\n    },\n\n    {\n      description: `Lists of Scalar types`,\n      test: field =>\n        field.type.kind === `LIST` && field.type.ofType.kind === `SCALAR`,\n\n      transform: ({ field }) => {\n        if (typeIsABuiltInScalar(field.type)) {\n          return `[${field.type.ofType.name}]`\n        } else {\n          return `[JSON]`\n        }\n      },\n    },\n\n    {\n      description: `Lists of Interface types`,\n      test: field =>\n        field.type.kind === `LIST` && field.type.ofType.kind === `INTERFACE`,\n\n      transform: ({ field }) =>\n        `[${buildTypeName(findNamedTypeName(field.type), prefix)}]`,\n    },\n\n    {\n      description: `Union type`,\n      test: field => field.type.kind === `UNION`,\n      transform: args => transformUnion({ ...args, pluginOptions }),\n    },\n\n    {\n      description: `Interface type`,\n      test: field => field.type.kind === `INTERFACE`,\n      transform: ({ field }) => buildTypeName(field.type.name, prefix),\n    },\n\n    {\n      description: `Lists of NON_NULL types`,\n      test: field =>\n        findTypeKind(field.type) !== `LIST` && field.type.kind === `NON_NULL`,\n      transform: ({ field }) =>\n        `${buildTypeName(findNamedTypeName(field.type), prefix)}!`,\n    },\n\n    // for finding unhandled types\n    // {\n    //   description: `Unhandled type`,\n    //   test: () => true,\n    //   transform: ({ field }) => dd(field),\n    // },\n  ]\n}\n"],"mappings":"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"}