"use strict";

exports.__esModule = true;
exports.typeIsExcluded = exports.fieldIsExcludedOnParentType = exports.fieldIsExcludedOnAll = void 0;
var _store = require("../../store");
var _helpers = require("../create-schema-customization/helpers");
// these types do not work in Gatsby because there's no way to reliably invalidate caches or do partial data updates for them
const blockListedTypenameParts = [`PluginConnection`, `ThemeConnection`, `ActionMonitorAction`, `EnqueuedScript`, `EnqueuedStylesheet`, `EnqueuedAsset`];
const seenTypesWhileBlockingByParts = {};
function typenamePartIsBlocked(name) {
  if (seenTypesWhileBlockingByParts[name]) {
    return seenTypesWhileBlockingByParts[name];
  }
  const typenameContainsBlocklistedPart = !!blockListedTypenameParts.find(b => name === null || name === void 0 ? void 0 : name.includes(b));
  seenTypesWhileBlockingByParts[name] = typenameContainsBlocklistedPart;
  return typenameContainsBlocklistedPart;
}
const typeIsExcluded = ({
  pluginOptions,
  typeName
}) => typenamePartIsBlocked(typeName) || pluginOptions && pluginOptions.type[typeName] && pluginOptions.type[typeName].exclude;
exports.typeIsExcluded = typeIsExcluded;
const fieldIsExcludedOnAll = ({
  pluginOptions,
  field
}) => {
  var _pluginOptions$type, _allFieldSettings$exc;
  const allFieldSettings = pluginOptions === null || pluginOptions === void 0 ? void 0 : (_pluginOptions$type = pluginOptions.type) === null || _pluginOptions$type === void 0 ? void 0 : _pluginOptions$type.__all;
  if (!allFieldSettings) {
    return false;
  }
  return !!(allFieldSettings !== null && allFieldSettings !== void 0 && (_allFieldSettings$exc = allFieldSettings.excludeFieldNames) !== null && _allFieldSettings$exc !== void 0 && _allFieldSettings$exc.includes(field === null || field === void 0 ? void 0 : field.name));
};
exports.fieldIsExcludedOnAll = fieldIsExcludedOnAll;
const fieldIsExcludedOnParentType = ({
  field,
  parentType
}) => {
  var _fullType$fields, _parentTypeNameSettin, _parentTypeNodesField;
  const state = (0, _store.getStore)().getState();
  const {
    typeMap
  } = state.remoteSchema;
  const fullType = typeMap.get((0, _helpers.findNamedTypeName)(parentType));
  const parentTypeNodesField = fullType === null || fullType === void 0 ? void 0 : (_fullType$fields = fullType.fields) === null || _fullType$fields === void 0 ? void 0 : _fullType$fields.find(field => field.name === `nodes`);
  const parentTypeNameSettings = (0, _helpers.getTypeSettingsByType)(parentType);
  const parentTypeNodesFieldTypeNameSettings = (0, _helpers.getTypeSettingsByType)(parentTypeNodesField === null || parentTypeNodesField === void 0 ? void 0 : parentTypeNodesField.type);
  const fieldIsExcludedOnParentType =
  // if this field is excluded on either the parent type
  (parentTypeNameSettings === null || parentTypeNameSettings === void 0 ? void 0 : (_parentTypeNameSettin = parentTypeNameSettings.excludeFieldNames) === null || _parentTypeNameSettin === void 0 ? void 0 : _parentTypeNameSettin.includes(field === null || field === void 0 ? void 0 : field.name)) || ( // or the parent type has a "nodes" field and that type has this field excluded
  parentTypeNodesFieldTypeNameSettings === null || parentTypeNodesFieldTypeNameSettings === void 0 ? void 0 : (_parentTypeNodesField = parentTypeNodesFieldTypeNameSettings.excludeFieldNames) === null || _parentTypeNodesField === void 0 ? void 0 : _parentTypeNodesField.includes(field === null || field === void 0 ? void 0 : field.name));
  return !!fieldIsExcludedOnParentType;
};
exports.fieldIsExcludedOnParentType = fieldIsExcludedOnParentType;
//# sourceMappingURL=is-excluded.js.map