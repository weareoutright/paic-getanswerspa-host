{"version":3,"file":"recursively-transform-fields.js","names":["transformInlineFragments","possibleTypes","gatsbyNodesInfo","typeMap","maxDepth","parentType","mainType","parentField","fragments","circularQueryLimit","buildGatsbyNodeFields","depth","buildingFragment","ancestorTypeNames","parentAncestorTypeNames","state","getStore","getState","remoteSchema","pluginOptions","gatsbyApi","schema","queryDepth","transformedInlineFragments","map","possibleType","type","get","name","typeSettings","getTypeSettingsByType","exclude","typeIsExcluded","typeName","findNamedTypeName","dispatch","addFetchedType","isAGatsbyNode","typeNames","includes","fields","typeInfo","filteredFields","kind","filter","filteredField","find","recursivelyTransformFields","length","Boolean","countIncarnations","ancestorTypeName","transformField","field","fieldBlacklist","fieldAliases","typeKind","findTypeKind","typeIncarnationCount","createFragment","fieldName","returnAliasedFieldName","args","arg","fieldType","ofType","isListOfGatsbyNodes","isListOfMediaItems","hasIdField","listOfType","transformedFields","inlineFragments","every","parentFieldName","previouslyCreatedFragment","fragmentFields","reduce","fieldTypeName","innerFieldField","transformedField","push","queryType","transformFields","fieldIsExcludedOnParentType","fieldIsExcludedOnAll","fragment","fragmentField","internalType","fieldInlineFragment","fragmentInlineFragment","fieldTypeKind","fieldOfTypeKind","typeKindsRequiringSelectionSets","fieldNeedsSelectionSet","grandParentTypeName","recursivelyTransformedFields"],"sources":["../../../../src/steps/ingest-remote-schema/build-queries-from-introspection/recursively-transform-fields.js"],"sourcesContent":["import { getStore } from \"~/store\"\nimport {\n  getTypeSettingsByType,\n  findNamedTypeName,\n  findTypeKind,\n} from \"~/steps/create-schema-customization/helpers\"\nimport {\n  fieldIsExcludedOnParentType,\n  fieldIsExcludedOnAll,\n} from \"~/steps/ingest-remote-schema/is-excluded\"\nimport { returnAliasedFieldName } from \"~/steps/create-schema-customization/transform-fields\"\nimport { typeIsExcluded } from \"../is-excluded\"\n\nexport const transformInlineFragments = ({\n  possibleTypes,\n  gatsbyNodesInfo,\n  typeMap,\n  maxDepth,\n  parentType,\n  mainType,\n  parentField,\n  fragments,\n  circularQueryLimit,\n  buildGatsbyNodeFields = false,\n  depth = 0,\n  buildingFragment = false,\n  ancestorTypeNames: parentAncestorTypeNames = [],\n}) => {\n  const state = getStore().getState()\n\n  if (!typeMap) {\n    typeMap = state.remoteSchema.typeMap\n  }\n\n  const { pluginOptions } = state.gatsbyApi\n\n  if (!maxDepth) {\n    maxDepth = pluginOptions.schema.queryDepth\n  }\n\n  if (!circularQueryLimit) {\n    circularQueryLimit = pluginOptions.circularQueryLimit\n  }\n\n  if (!gatsbyNodesInfo) {\n    gatsbyNodesInfo = state.remoteSchema.gatsbyNodesInfo\n  }\n\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  const transformedInlineFragments = possibleTypes\n    .map(possibleType => {\n      possibleType = { ...possibleType }\n\n      const type = typeMap.get(possibleType.name)\n\n      if (!type) {\n        return false\n      }\n\n      const typeSettings = getTypeSettingsByType(type)\n\n      if (typeSettings.exclude) {\n        return false\n      }\n\n      if (\n        typeIsExcluded({\n          pluginOptions,\n          typeName: findNamedTypeName(type),\n        })\n      ) {\n        return false\n      }\n\n      possibleType.type = { ...type }\n\n      // save this type so we can use it in schema customization\n      getStore().dispatch.remoteSchema.addFetchedType(type)\n\n      const isAGatsbyNode = gatsbyNodesInfo.typeNames.includes(\n        possibleType.name\n      )\n\n      if (isAGatsbyNode && !buildGatsbyNodeFields) {\n        // we use the id to link to the top level Gatsby node\n        possibleType.fields = [`id`]\n        return possibleType\n      }\n\n      const typeInfo = typeMap.get(possibleType.name)\n\n      let filteredFields = [...typeInfo.fields]\n\n      if (parentType?.kind === `INTERFACE`) {\n        // remove any fields from our fragment if the parent type already has them as shared fields\n        filteredFields = filteredFields.filter(\n          filteredField =>\n            !parentType.fields.find(\n              parentField => parentField.name === filteredField.name\n            )\n        )\n      }\n\n      if (typeInfo) {\n        const fields = recursivelyTransformFields({\n          fields: filteredFields,\n          parentType: type,\n          depth,\n          ancestorTypeNames,\n          fragments,\n          buildingFragment,\n          circularQueryLimit,\n          mainType,\n          parentField,\n        })\n\n        if (!fields || !fields.length) {\n          return false\n        }\n\n        possibleType.fields = [...fields]\n        return possibleType\n      }\n\n      return false\n    })\n    .filter(Boolean)\n\n  return possibleTypes && depth <= maxDepth ? transformedInlineFragments : null\n}\n\n// since we're counting circular types that may be on fields many levels up, incarnation felt like it works here ;) the types are born again in later generations\nconst countIncarnations = ({ typeName, ancestorTypeNames }) =>\n  ancestorTypeNames.length\n    ? ancestorTypeNames.filter(\n        ancestorTypeName => ancestorTypeName === typeName\n      )?.length\n    : 0\n\nexport function transformField({\n  field,\n  gatsbyNodesInfo,\n  typeMap,\n  maxDepth,\n  depth,\n  fieldBlacklist,\n  fieldAliases,\n  ancestorTypeNames: parentAncestorTypeNames,\n  circularQueryLimit,\n  fragments,\n  buildingFragment,\n  mainType,\n} = {}) {\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  // we're potentially infinitely recursing when fields are connected to other types that have fields that are connections to other types\n  //  so we need a maximum limit for that\n  if (depth > maxDepth) {\n    return false\n  }\n\n  depth++\n\n  // if the field has no type we can't use it.\n  if (!field || !field.type) {\n    return false\n  }\n\n  const typeSettings = getTypeSettingsByType(field.type)\n\n  if (typeSettings.exclude) {\n    return false\n  }\n\n  // count the number of times this type has appeared as an ancestor of itself\n  // somewhere up the tree\n  const typeName = findNamedTypeName(field.type)\n  const typeKind = findTypeKind(field.type)\n\n  const typeIncarnationCount = countIncarnations({\n    typeName,\n    ancestorTypeNames,\n  })\n\n  if (typeIncarnationCount > 0) {\n    // this type is nested within itself atleast once\n    // create a fragment here that can be reused\n    createFragment({\n      fields: typeMap.get(typeName).fields,\n      type: field.type,\n      fragments,\n      field,\n      ancestorTypeNames: parentAncestorTypeNames,\n      depth,\n      fieldBlacklist,\n      fieldAliases,\n      typeMap,\n      gatsbyNodesInfo,\n      circularQueryLimit,\n      queryDepth: maxDepth,\n      buildingFragment,\n      mainType,\n    })\n  }\n\n  if (typeIncarnationCount >= circularQueryLimit) {\n    return false\n  }\n\n  // this is used to alias fields that conflict with Gatsby node fields\n  // for ex Gatsby and WPGQL both have a `parent` field\n  const fieldName = returnAliasedFieldName({ fieldAliases, field })\n\n  if (\n    fieldBlacklist.includes(field.name) ||\n    fieldBlacklist.includes(fieldName)\n  ) {\n    return false\n  }\n\n  // remove fields that have required args. They'll cause query errors if omitted\n  //  and we can't determine how to use those args programatically.\n  if (\n    field.args &&\n    field.args.length &&\n    field.args.find(arg => arg?.type?.kind === `NON_NULL`)\n  ) {\n    return false\n  }\n\n  const fieldType = typeMap.get(findNamedTypeName(field.type)) || {}\n  const ofType = typeMap.get(findNamedTypeName(fieldType.ofType)) || {}\n\n  if (\n    fieldType.kind === `SCALAR` ||\n    fieldType.kind === `ENUM` ||\n    (fieldType.kind === `NON_NULL` && ofType.kind === `SCALAR`) ||\n    (fieldType.kind === `LIST` && fieldType.ofType.kind === `SCALAR`) ||\n    // a list of enums has no type name, so findNamedTypeName above finds the enum type\n    // instead of the field type. Need to explicitly check here\n    // instead of using helpers\n    (field.type.kind === `LIST` && field.type?.ofType?.kind === `ENUM`)\n  ) {\n    return {\n      fieldName,\n      fieldType,\n    }\n  }\n\n  const isListOfGatsbyNodes =\n    ofType && gatsbyNodesInfo.typeNames.includes(typeName)\n\n  const isListOfMediaItems = ofType && typeName === `MediaItem`\n\n  const hasIdField = fieldType?.fields?.find(({ name }) => name === `id`)\n  if (\n    fieldType.kind === `LIST` &&\n    isListOfGatsbyNodes &&\n    !isListOfMediaItems &&\n    hasIdField\n  ) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  } else if (fieldType.kind === `LIST` && isListOfMediaItems && hasIdField) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  } else if (fieldType.kind === `LIST`) {\n    const listOfType = typeMap.get(findNamedTypeName(fieldType))\n\n    const transformedFields = recursivelyTransformFields({\n      fields: listOfType.fields,\n      parentType: listOfType || fieldType,\n      depth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n      mainType,\n    })\n\n    const transformedInlineFragments = transformInlineFragments({\n      possibleTypes: listOfType.possibleTypes,\n      parentType: listOfType || fieldType,\n      parentField: field,\n      mainType,\n      gatsbyNodesInfo,\n      typeMap,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    if (!transformedFields?.length && !transformedInlineFragments?.length) {\n      return false\n    }\n\n    // if we have either inlineFragments or fields\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments: transformedInlineFragments,\n      fieldType,\n    }\n  }\n\n  const isAGatsbyNode =\n    // if this is a gatsby node type\n    gatsbyNodesInfo.typeNames.includes(typeName) ||\n    // or all possible types on this type are Gatsby node types\n    typeMap\n      .get(typeName)\n      ?.possibleTypes?.every(possibleType =>\n        gatsbyNodesInfo.typeNames.includes(possibleType.name)\n      )\n\n  if (isAGatsbyNode && hasIdField) {\n    return {\n      fieldName: fieldName,\n      fields: [`__typename`, `id`],\n      fieldType,\n    }\n  }\n\n  const typeInfo = typeMap.get(findNamedTypeName(fieldType))\n\n  const { fields } = typeInfo || {}\n\n  let transformedInlineFragments\n\n  if (typeInfo.possibleTypes) {\n    transformedInlineFragments = transformInlineFragments({\n      possibleTypes: typeInfo.possibleTypes,\n      parentType: typeInfo,\n      parentField: field,\n      mainType,\n      gatsbyNodesInfo,\n      typeMap,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n  }\n\n  if (fields || transformedInlineFragments) {\n    const transformedFields = recursivelyTransformFields({\n      parentType: typeInfo,\n      parentFieldName: field.name,\n      mainType,\n      fields,\n      depth,\n      ancestorTypeNames,\n      parentField: field,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    if (!transformedFields?.length && !transformedInlineFragments?.length) {\n      return false\n    }\n\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments: transformedInlineFragments,\n      fieldType,\n    }\n  }\n\n  if (fieldType.kind === `UNION`) {\n    const typeInfo = typeMap.get(fieldType.name)\n\n    const transformedFields = recursivelyTransformFields({\n      fields: typeInfo.fields,\n      parentType: fieldType,\n      mainType,\n      depth,\n      ancestorTypeNames,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    const inlineFragments = transformInlineFragments({\n      possibleTypes: typeInfo.possibleTypes,\n      gatsbyNodesInfo,\n      typeMap,\n      mainType,\n      depth,\n      maxDepth,\n      ancestorTypeNames,\n      parentField: field,\n      fragments,\n      circularQueryLimit,\n      buildingFragment,\n    })\n\n    return {\n      fieldName: fieldName,\n      fields: transformedFields,\n      inlineFragments,\n      fieldType,\n    }\n  }\n\n  return false\n}\n\nconst createFragment = ({\n  fields,\n  field,\n  type,\n  fragments,\n  fieldBlacklist,\n  fieldAliases,\n  typeMap,\n  gatsbyNodesInfo,\n  queryDepth,\n  ancestorTypeNames,\n  mainType,\n  buildingFragment = false,\n}) => {\n  const typeName = findNamedTypeName(type)\n\n  if (buildingFragment) {\n    // this fragment is inside a fragment that's already being built so we should exit\n    return null\n  }\n\n  const previouslyCreatedFragment = fragments?.[typeName]\n\n  if (previouslyCreatedFragment && buildingFragment === typeName) {\n    return previouslyCreatedFragment\n  }\n\n  const fragmentFields = fields.reduce((fragmentFields, field) => {\n    const fieldTypeName = findNamedTypeName(field.type)\n    const fieldType = typeMap.get(fieldTypeName)\n\n    if (\n      // if this field is a different type than the fragment but has a field of the same type as the fragment,\n      // we need to skip this field in the fragment to prevent nesting this type in itself a level down\n      fieldType.name !== typeName &&\n      fieldType?.fields?.find(\n        innerFieldField => findNamedTypeName(innerFieldField.type) === typeName\n      )\n    ) {\n      return fragmentFields\n    }\n\n    const transformedField = transformField({\n      field,\n      gatsbyNodesInfo,\n      typeMap,\n      maxDepth: queryDepth,\n      depth: 0,\n      fieldBlacklist,\n      fieldAliases,\n      ancestorTypeNames,\n      mainType,\n      circularQueryLimit: 1,\n      fragments,\n      buildingFragment: typeName,\n    })\n\n    if (findNamedTypeName(field.type) !== typeName && !!transformedField) {\n      fragmentFields.push(transformedField)\n    }\n\n    return fragmentFields\n  }, [])\n\n  const queryType = typeMap.get(typeName)\n\n  const transformedInlineFragments = queryType?.possibleTypes?.length\n    ? transformInlineFragments({\n        possibleTypes: queryType.possibleTypes,\n        parentType: queryType,\n        parentField: field,\n        mainType,\n        gatsbyNodesInfo,\n        typeMap,\n        depth: 0,\n        maxDepth: queryDepth,\n        circularQueryLimit: 1,\n        ancestorTypeNames,\n        fragments,\n        buildingFragment: typeName,\n      })\n    : null\n\n  if (fragments) {\n    fragments[typeName] = {\n      name: `${typeName}Fragment`,\n      type: typeName,\n      fields: fragmentFields,\n      inlineFragments: transformedInlineFragments,\n    }\n  }\n\n  return fragmentFields\n}\n\nconst transformFields = ({\n  fields,\n  parentType,\n  mainType,\n  fragments,\n  parentField,\n  ancestorTypeNames,\n  depth,\n  fieldBlacklist,\n  fieldAliases,\n  typeMap,\n  gatsbyNodesInfo,\n  queryDepth,\n  circularQueryLimit,\n  pluginOptions,\n  buildingFragment,\n}) =>\n  fields\n    ?.filter(\n      field =>\n        !fieldIsExcludedOnParentType({\n          field,\n          parentType,\n        }) &&\n        !fieldIsExcludedOnAll({\n          pluginOptions,\n          field,\n        }) &&\n        !typeIsExcluded({\n          pluginOptions,\n          typeName: findNamedTypeName(field.type),\n        })\n    )\n    .map(field => {\n      const transformedField = transformField({\n        maxDepth: queryDepth,\n        gatsbyNodesInfo,\n        fieldBlacklist,\n        fieldAliases,\n        typeMap,\n        field,\n        depth,\n        ancestorTypeNames,\n        circularQueryLimit,\n        fragments,\n        buildingFragment,\n        mainType,\n        parentField,\n      })\n\n      if (transformedField) {\n        // save this type so we know to use it in schema customization\n        getStore().dispatch.remoteSchema.addFetchedType(field.type)\n      }\n\n      const typeName = findNamedTypeName(field.type)\n      const fragment = fragments?.[typeName]\n\n      // @todo add any adjacent fields and inline fragments directly to the stored fragment object so this logic can be changed to if (fragment) useTheFragment()\n      // once that's done it can be added above and below transformField() above ☝️\n      // and potentially short circuit expensive work that will be thrown away anyway\n      if (fragment && transformedField && buildingFragment !== typeName) {\n        // if (fragment && buildingFragment !== typeName && transformedField) {\n        // remove fields from this query that already exist in the fragment\n        if (transformedField?.fields?.length) {\n          transformedField.fields = transformedField.fields.filter(\n            field =>\n              !fragment.fields.find(\n                fragmentField => fragmentField.fieldName === field.fieldName\n              )\n          )\n        }\n\n        // if this field has no fields (because it has inline fragments only)\n        // we need to create an empty array since we treat reusable fragments as\n        // a field\n        if (!transformedField.fields) {\n          transformedField.fields = []\n        }\n\n        transformedField.fields.push({\n          internalType: `Fragment`,\n          fragment,\n        })\n\n        if (transformedField?.inlineFragments?.length) {\n          transformedField.inlineFragments =\n            transformedField.inlineFragments.filter(\n              fieldInlineFragment =>\n                // yes this is a horrible use of .find(). @todo refactor this for better perf\n                !fragment.inlineFragments.find(\n                  fragmentInlineFragment =>\n                    fragmentInlineFragment.name === fieldInlineFragment.name\n                )\n            )\n        }\n      }\n\n      if (field.fields && !transformedField) {\n        return null\n      }\n\n      const fieldTypeKind = findTypeKind(field.type)\n      const fieldOfTypeKind = findTypeKind(field.type.ofType)\n      const typeKindsRequiringSelectionSets = [`OBJECT`, `UNION`, `INTERFACE`]\n      const fieldNeedsSelectionSet =\n        typeKindsRequiringSelectionSets.includes(fieldTypeKind) ||\n        typeKindsRequiringSelectionSets.includes(fieldOfTypeKind)\n\n      if (\n        // if our field needs a selectionset\n        fieldNeedsSelectionSet &&\n        // but we have no fields\n        !transformedField.fields &&\n        // and no inline fragments\n        !transformedField.inlineFragments\n      ) {\n        // we need to discard this field to prevent GraphQL errors\n        // we're likely at the very bottom of the query depth\n        // so that this fields children were omitted\n        return null\n      }\n\n      return transformedField\n    })\n    .filter(Boolean)\n\nconst recursivelyTransformFields = ({\n  fields,\n  parentType,\n  mainType,\n  fragments,\n  parentField,\n  ancestorTypeNames: parentAncestorTypeNames,\n  depth = 0,\n  buildingFragment = false,\n}) => {\n  if (!fields || !fields.length) {\n    return null\n  }\n\n  if (!parentAncestorTypeNames) {\n    parentAncestorTypeNames = []\n  }\n\n  const ancestorTypeNames = [...parentAncestorTypeNames]\n\n  const {\n    gatsbyApi: { pluginOptions },\n    remoteSchema: { fieldBlacklist, fieldAliases, typeMap, gatsbyNodesInfo },\n  } = getStore().getState()\n\n  const {\n    schema: { queryDepth, circularQueryLimit },\n  } = pluginOptions\n\n  if (depth > queryDepth && ancestorTypeNames.length) {\n    return null\n  }\n\n  const typeName = findNamedTypeName(parentType)\n\n  const grandParentTypeName = ancestorTypeNames.length\n    ? ancestorTypeNames[ancestorTypeNames.length - 1]\n    : null\n\n  if (grandParentTypeName && typeName !== grandParentTypeName) {\n    // if a field has fields of the same type as the field above it\n    // we shouldn't fetch them. 2 types that are circular between each other\n    // are dangerous as they will generate very large queries and fetch data we don't need\n    // these types should instead be proper connections so we can identify\n    // that only an id needs to be fetched.\n    // @todo maybe move this into transformFields() instead of here\n    fields = fields.filter(field => {\n      const fieldTypeName = findNamedTypeName(field.type)\n      return fieldTypeName !== grandParentTypeName\n    })\n  }\n\n  const typeIncarnationCount = countIncarnations({\n    typeName,\n    ancestorTypeNames,\n  })\n\n  if (typeIncarnationCount >= circularQueryLimit) {\n    return null\n  }\n\n  parentAncestorTypeNames.push(typeName)\n\n  const recursivelyTransformedFields = transformFields({\n    fields,\n    parentType,\n    mainType,\n    fragments,\n    parentField,\n    ancestorTypeNames: parentAncestorTypeNames,\n    depth,\n    fieldBlacklist,\n    fieldAliases,\n    typeMap,\n    gatsbyNodesInfo,\n    queryDepth,\n    circularQueryLimit,\n    pluginOptions,\n    buildingFragment,\n  })\n\n  if (!recursivelyTransformedFields.length) {\n    return null\n  }\n\n  return recursivelyTransformedFields\n}\n\nexport default recursivelyTransformFields\n"],"mappings":"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"}